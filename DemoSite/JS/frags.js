



var frag0 = [
	"precision mediump float;   ",
	"uniform vec2 mouse;  ",
	"uniform float time; ",
	"uniform vec2 resolution; ",
	"varying vec2 surfacePosition; ",
	" ",
	" ",
	"vec3 LIGHT_DIR = normalize(vec3(0,1.1,-0.8)); ",
	"vec3 CAMERA_POS = vec3(0.0, 0.8, -1.5); ",
	" ",
	"mat3 rotate3d(vec3 axis, float angle) { ",
	"	axis = normalize(axis); ",
	"	float s = sin(angle); ",
	"	float c = cos(angle); ",
	"	float oc = 1.0 - c; ",
	" ",
	"	return mat3(oc*axis.x*axis.x+c, oc*axis.x*axis.y - axis.z*s, oc*axis.z*axis.x + axis.y*s, ",
	"	oc*axis.x*axis.y+axis.z*s, oc*axis.y*axis.y+c, oc * axis.y*axis.z - axis.x*s, ",
	"	oc*axis.z*axis.x-axis.y*s, oc*axis.y*axis.z+axis.x*s, oc*axis.z*axis.z+c); ",
	"} ",
	" ",
	"float de(in vec3 p) { ",
	"	p = rotate3d(vec3(sin(time*0.25),sin(time*0.125),sin(time*0.1125)),time)*p; ",
	" ",
	"	for(int i = 0; i < 3; i++) { ",
	"	p *= normalize(p); ",
	"	p = rotate3d(vec3(sin(time*0.25),sin(time*0.125),sin(time*0.1125)),time+sin(time*0.321)+cos(float(i)+time*0.231))*p; ",
	"	} ",
	" ",
	"	return length(p) - 0.1; ",
	"} ",
	" ",
	"vec3 ray_march(in vec3 p, in vec3 dir) { ",
	"	float td = 0.0; ",
	"	for(int i = 0; i < 12; i++) { ",
	"		td += de(p + td*dir); ",
	"	} ",
	"	return p + td*dir; ",
	"} ",
	" ",
	"vec3 normal(in vec3 p) { ",
	"	const vec3 E = vec3(0.00001, 0.0, 0.0); ",
	"	return normalize(vec3( ",
	"	de(p+E.xyy)-de(p-E.xyy), ",
	"	de(p+E.yxy)-de(p-E.yxy), ",
	"	de(p+E.yyx)-de(p-E.yyx) ",
	"	)); ",
	"} ",
	" ",
	"const float SHININESS = 1.1; ",
	"vec3 view = normalize(vec3(1.)); ",
	"vec3 specular_reflection(in vec3 normal, in vec3 dir) { ",
	"	if (dot(normal, LIGHT_DIR) < 0.0) { ",
	"		return vec3(0.0, 0.0, 0.0); ",
	"	} ",
	"	else { ",
	"		return vec3(1.)*pow(dot(reflect(-LIGHT_DIR, normal), view), SHININESS); ",
	"	} ",
	"} ",
	" ",
	"float diffuse_factor(in vec3 normal) { ",
	"	return 2.*clamp(dot(normal, LIGHT_DIR), 0.1, 1.0); ",
	"} ",
	" ",
	"vec4 color(in vec3 p) { ",
	"	vec3 norm = normal(p); ",
	"	return vec4(norm*norm,1.)*diffuse_factor(p); ",
	"} ",
	" ",
	"void main(void) { ",
	"	vec2 screen = 2.*(gl_FragCoord.xy / resolution.xy * vec2(1., resolution.y/resolution.x) - vec2(0.5)); ",
	" ",
	"	vec3 dir = normalize(vec3(screen.xy, 0.9)); ",
	"	vec3 p = CAMERA_POS; ",
	" ",
	"	vec3 end = ray_march(p, dir); ",
	" ",
	"	gl_FragColor = 2.*(color(end)+vec4(specular_reflection(normal(end), dir),0.)/2.5)/(distance(end,p)-0.5); ",
	"} ",
].join("\n");

var frag1 = [
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	"// YOU'RE ABOUT ",
	"// TO HACK TIME, ",
	"// ARE YOU SURE? ",
	"//  >YES   NO ",
	" ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	" ",
	"void glow(float d) { ",
	"	float br = 0.005 * resolution.y; ",
	"	gl_FragColor.rgb += vec3(0.3, 0.15, 0.45) * br / d; ",
	"} ",
	" ",
	"void line( vec2 a, vec2 l ) { ",
	"	l.x *= resolution.y/resolution.x; ",
	"	l += 0.5; ",
	"	l *= resolution; ",
	"	 ",
	"	vec2 P = gl_FragCoord.xy; ",
	"	a.x *= resolution.y/resolution.x; ",
	"	a += 0.5; ",
	"	a *= resolution; ",
	"	 ",
	"	vec2 aP = P-a; ",
	"	vec2 al = l-a; ",
	"	vec3 al3 = vec3(al, 1.0); ",
	"	vec3 aP3 = vec3(aP, 1.1); ",
	"	//float q = length(dot(aP,al))/length(al); ",
	"	float q = length(cross(aP3,al3))/length(al3); ",
	"	 ",
	"	float d = q; ",
	"	if ( dot(al, aP) <= 0.0 ) { // before start ",
	"               d = distance(P, a); ",
	"	} ",
	"        else if ( dot(al, al) <= dot(al, aP) ) { // after end ",
	"               d = distance(P, l); ",
	"	} ",
	"	glow(d); ",
	"} ",
	" ",
	"void point(vec2 a) { ",
	"	a.x *= resolution.y/resolution.x; ",
	"	a += 0.5; ",
	"	a *= resolution; ",
	" ",
	"	vec2 P = gl_FragCoord.xy; ",
	"	float d = distance(P, a); ",
	"	glow(d); ",
	"} ",
	" ",
	"float rand(int seed) { ",
	"	return fract(sin(float(seed)*15.234234) + sin(float(seed)*4.3456342) * 372.4532); ",
	"} ",
	" ",
	"void main( void ) { ",
	"	gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); ",
	" ",
	"	// Horizontal grid lines ",
	"	float y = 0.0; ",
	"	for (int l=1; l<13; l++) { ",
	"		y = -1.0/(0.6 * sin(time * 0.73) + float(l)*1.2) + 0.25; ",
	"		line(vec2(-2.0, y), vec2(2.0, y)); ",
	"	} ",
	"	 ",
	"	// Perpendicular grid lines ",
	"	for (int l=-30; l<31; l++) { ",
	"		float x = float(l) + fract(time * 3.25); ",
	"		line(vec2(x * 0.025, y), vec2(x, -1.0)); ",
	"	} ",
	"	 ",
	"	// Starfield ",
	"	for (int l=1; l<70; l++) { ",
	"		float sx = (fract(rand(l+342) + time * (0.002 + 0.01*rand(l)))-0.5) * 3.0; ",
	"		float sy = y + 0.4 * rand(l+8324); ",
	"		point(vec2(sx,sy)); ",
	"	} ",
	"} ",
].join("\n");

var frag2 = [
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	" ",
	"float tt = time * 2.0; ",
	"vec2 random2f(vec2 p) { ",
	"	vec2 tmp = fract(vec2(sin(p.x * 797. + p.y * 311.), cos(p.x * 43. + p.y * 4111.))); ",
	"	return vec2(.5+.5*sin(tmp.x*tt + p.y),.5+.5*cos(tmp.y*tt + p.x)); ",
	"} ",
	" ",
	"float voronoi( in vec2 x ) ",
	"{ ",
	"    vec2 p = vec2(floor( x )); ",
	"    vec2 f = fract( x ); ",
	" ",
	"    float res = 9.0; ",
	"    const float s = 1.0;	 ",
	"    for( float j=-s; j<=s; j++ ) { ",
	"        for( float i=-s; i<=s; i++ ) { ",
	"		for(int a=0; a<=8; a++) { ",
	"	    vec2 b = vec2(i, j); ",
	"	    vec2  r = b - f + random2f(b + p); ",
	"	    float d = length(r); ",
	"	    res = min(res, d); ",
	"		} ",
	"        } ",
	"    } ",
	"    return res; ",
	"} ",
	" ",
	"void main( void ) { ",
	" ",
	"	vec2 p = gl_FragCoord.xy / resolution.xy; ",
	"	p.x *= resolution.x / resolution.y; ",
	"	vec2 q = 2.0 * p - 1.0; ",
	"	 ",
	"	float col = voronoi(q * 9.0); ",
	" 	      col = pow(col,0.9); ",
	"	gl_FragColor = vec4(1.-col,col-0.5,col-0.1, 1.0); ",
	"} ",
].join("\n");

var frag3 = [
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	"// rakesh@picovico.com : www.picovico.com ",
	" ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	" ",
	"const float fRadius = 0.1; ",
	" ",
	"void main(void) ",
	"{ ",
	"    vec2 uv = -1.0 + 2.0*gl_FragCoord.xy / resolution.xy; ",
	"    uv.x *=  resolution.x / resolution.y; ",
	"     ",
	"    vec3 color = vec3(0.0); ",
	" ",
	"        // bubbles ",
	"    for( int i=0; i<64; i++ ) ",
	"    { ",
	"            // bubble seeds ",
	"        float pha = tan(float(i)*6.+1.0)*0.5 + 0.5; ",
	"        float siz = pow( cos(float(i)*2.4+5.0)*0.5 + 0.5, 4.0 ); ",
	"        float pox = cos(float(i)*3.55+4.1) * resolution.x / resolution.y; ",
	"         ",
	"            // buble size, position and color ",
	"        float rad = fRadius + sin(float(i))*0.12+0.08; ",
	"        vec2  pos = vec2( pox+sin(time/30.+pha+siz), -1.0-rad + (2.0+2.0*rad) ",
	"                         *mod(pha+0.1*(time/5.)*(0.2+0.8*siz),1.0)) * vec2(1.0, 1.0); ",
	"        float dis = length( uv - pos ); ",
	"        vec3  col = mix( vec3(0.7, 0.2, 0.8), vec3(0.2,0.8,0.6), 0.5+0.5*sin(float(i)*sin(time*pox*0.03)+1.9)); ",
	"         ",
	"            // render ",
	"        color += col.xyz *(1.- smoothstep( rad*(0.65+0.20*sin(pox*time)), rad, dis )) * (1.0 - cos(pox*time)); ",
	"    } ",
	" ",
	"    gl_FragColor = vec4(color,1.0); ",
	"} ",
].join("\n");

var frag4 = [
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	"#extension GL_OES_standard_derivatives : enable ",
	" ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	" ",
	"void main( void ) { ",
	" ",
	"	vec2 position 	= ( gl_FragCoord.xy / resolution.xy ); ",
	"	position 	*= resolution/min(resolution.x,resolution.y); ",
	" ",
	"	vec3 color = vec3( ",
	"		fract(position.x / position.y * time ), ",
	"		fract(position.y / position.x * time),  ",
	"		cos(time) ",
	"		); ",
	"	 ",
	" ",
	"	gl_FragColor = vec4( color, 1.0 ); ",
	" ",
	"} ",
].join("\n");

var frag5 = [
	"// Guyver ",
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	" ",
	"uniform float time; ",
	"uniform float lowFreq; ",
	"uniform vec2 resolution; ",
	" ",
	" ",
	"vec3 SUN_1 = vec3(0.0,0.5,1.0); ",
	"vec3 SUN_2 = vec3(1.0,0.0,0.0); ",
	"vec3 SUN_3 = vec3(0.1,1.0,0.753); ",
	"vec3 SUN_4 = vec3(0.6,0.8,0.0); ",
	" ",
	" ",
	"float sigmoid(float x) ",
	"{ ",
	"	return 2./(1. + exp2(-x)) - 1.; ",
	"} ",
	" ",
	" ",
	"void main( void )  ",
	"{ ",
	"	vec2 position = gl_FragCoord.xy; ",
	"	vec2 aspect = vec2(resolution/resolution ); ",
	"	position -= 0.5*resolution; ",
	"	vec2 position2 = 0.5 + (position-0.5)/resolution*3.; ",
	"	 ",
	"	float filter = sigmoid(pow(2.,7.5)*(length((position/resolution + 0.5)*aspect) - 0.015))*0.5 +0.5 +lowFreq*lowFreq; ",
	"	position = mix(position, position2, filter) - 0.5; ",
	" ",
	"	vec3 color = vec3(0.); ",
	"	float angle = atan(position.y,position.x); ",
	"	float d = length(position); ",
	"	 ",
	"	color += 0.08/length(vec2(.05,2.0*position.y+sin(position.x*10.+time*-6.)))*SUN_3;  ",
	"	color += 0.07/length(vec2(.06,4.0*position.y+sin(position.x*10.+time*-2.)))*SUN_1; // I'm sure there's an easier way to do this, this just happened to look nice and blurry. ",
	"	color += 0.06/length(vec2(.07,8.0*position.y+sin(position.x*10.+time*2.)))*SUN_2; ",
	"	color += 0.05/length(vec2(.08,16.0*position.y+sin(position.x*10.+time*6.)))*SUN_3; ",
	"	color += 0.04/length(vec2(.09,32.0*position.y+sin(position.x*10.+time*10.)))*SUN_4; ",
	"	 ",
	"	gl_FragColor = vec4(color, 1.0); ",
	"} ",
].join("\n");



var frag6 = [
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	" ",
	"#extension GL_OES_standard_derivatives : enable ",
	" ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	"float size = float(0.05); ",
	" ",
	"void main( void ) { ",
	" ",
	"	float mousedist = size/(length(mouse - (gl_FragCoord.xy/resolution.xy))); ",
	"	 ",
	"	float pointdist = size/length(vec2(0.5,0.5) - (gl_FragCoord.xy/resolution.xy)); ",
	"	 ",
	"	float color = 0.+mousedist+pointdist; ",
	"	 ",
	"	float r = color; ",
	"	float g = color-0.9; ",
	"	float b = 0.; ",
	"	 ",
	"	if(r > 1.){ ",
	"		r = 1.; ",
	"	} ",
	"	if(g > 1.){ ",
	"		g = 1.; ",
	"	} ",
	"	if(b > 1.){ ",
	"		b = 1.; ",
	"	} ",
	"	 ",
	"	gl_FragColor.r = float(r); ",
	"	gl_FragColor.g = float(g); ",
	"	gl_FragColor.b = float(b); ",
	" ",
	"} ",
].join("\n");

frag7 = [
	"//<!-- ",
	"/* ",
	"co3moz ",
	"github.com/co3moz ",
	" ",
	"draw => for y-finite solutions ",
	"drawYInfinite => for y-infinite solutions ",
	" ",
	"press left button of mouse and move for move. ",
	"press right button of mouse and move for scale. ",
	"press shift and left button of mouse, move a little bit will reset to default position. ",
	"*/ ",
	" ",
	"precision highp float; ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	"varying vec2 surfacePosition; ",
	" ",
	"#define draw(function, r, g, b) if(distance(function(p.x - c.x), p.y - c.y) < 0.01) color = vec3(r, g, b) ",
	"#define drawYInfinite(function, r, g, b) if(distance(function(p.x - c.x), p.y - c.y) < abs(function(p.x - c.x) - function(p.x - c.x - 0.01))) color = vec3(r, g, b) ",
	"#define mouseTrack(function) if(distance(mouse.x * aspect.x, p.x) < 0.003 && function(p.x - c.x) - p.y + c.y > 0.0 && sin((c.y - p.y) * 200.0) < 0.1) color = vec3(0.5, 0.5, 0.5) ",
	" ",
	"float y1(float x) { ",
	"	return x; ",
	"} ",
	" ",
	"float y2(float x) { ",
	"	return sin(x); ",
	"} ",
	" ",
	"float y3(float x) { ",
	"	return sin(x + time); ",
	"} ",
	" ",
	"void main(void) { ",
	"	vec2 aspect = resolution.xy / min(resolution.x, resolution.y); ",
	"	vec2 c = vec2(0.5) * aspect - surfacePosition * 1.5; ",
	"	vec2 p = gl_FragCoord.xy / min(resolution.x, resolution.y); ",
	"	vec3 color = vec3(0.0); ",
	"	 ",
	"	draw(y1, 1.0, 1.0, 1.0); // y1 ",
	"	draw(y2, 0.0, 0.0, 1.0); // y2 ",
	"	draw(y3, 0.0, 1.0, 1.0); // y3 ",
	"	mouseTrack(y3); // mouse tracking ",
	"	 ",
	"	if(distance(p.y, c.y) < 0.005 && sin((c.x - p.x) * 200.0) < 0.1) color = vec3(0.0, 1.0, 0.0); // horizontal ",
	"	if(distance(p.x, c.x) < 0.005 && sin((c.y - p.y) * 200.0) < 0.1) color = vec3(1.0, 0.0, 1.0); // vertical ",
	"	gl_FragColor = vec4(color, 1.0); ",
	"} ",
	"//--> ",
	" ",
].join("\n");

var frag8 = [
	"//stupid changes by @jakeukalane from 31147.0 ",
	" ",
	"#ifdef GL_ES ",
	"precision mediump float; ",
	"#endif ",
	"  ",
	"  ",
	"uniform float time; ",
	"uniform vec2 mouse; ",
	"uniform vec2 resolution; ",
	" ",
	" ",
	"#define iterations 4 ",
	"#define formuparam2 0.89 ",
	"  ",
	"#define volsteps 10 ",
	"#define stepsize 0.190 ",
	"  ",
	"#define zoom 3.900 ",
	"#define tile   0.450 ",
	"#define speed2  0.010 ",
	"  ",
	"#define brightness 0.2 ",
	"#define darkmatter 0.400 ",
	"#define distfading 0.560 ",
	"#define saturation 0.400 ",
	" ",
	" ",
	"#define transverseSpeed 1.1 ",
	"#define cloud 0.2 ",
	" ",
	"  ",
	"float triangle(float x, float a) ",
	"{ ",
	"  ",
	"  ",
	"float output2 = 2.0*abs(  2.0*  ( (x/a) - floor( (x/a) + 0.5) ) ) - 1.0; ",
	"return output2; ",
	"} ",
	"  ",
	" ",
	"float field(in vec3 p) { ",
	"	 ",
	"	float strength = 7. + .03 * log(1.e-6 + fract(sin(time) * 4373.11)); ",
	"	float accum = 0.; ",
	"	float prev = 0.; ",
	"	float tw = 0.; ",
	"	 ",
	" ",
	"	for (int i = 0; i < 6; ++i) { ",
	"		float mag = dot(p, p); ",
	"		p = abs(p) / mag + vec3(-.5, -.8 + 0.1*tan(time*0.2 + 2.0), -1.1+0.3*log(time*0.15)); ",
	"		float w = exp(-float(i) / 7.); ",
	"		accum += w * exp(-strength * pow(abs(mag - prev), 2.3)); ",
	"		tw += w; ",
	"		prev = mag; ",
	"	} ",
	"	return max(0., 5. * accum / tw - .7); ",
	"} ",
	" ",
	" ",
	" ",
	"void main() ",
	"{ ",
	"    ",
	"     	vec2 uv2 = 2. * gl_FragCoord.xy / resolution.xy - 1.; ",
	"	vec2 uvs = uv2 * resolution.xy / max(resolution.x, resolution.y); ",
	"	 ",
	" ",
	"	 ",
	"	float time2 = time; ",
	"                ",
	"        float speed = speed2; ",
	"        speed = 0.005 * cos(time2*0.02 + 3.1415926/4.0); ",
	"           ",
	"	//speed = 0.0; ",
	" ",
	"	 ",
	"    	float formuparam = formuparam2; ",
	" ",
	"	 ",
	"     ",
	"	//get coords and direction ",
	" ",
	"	vec2 uv = uvs; ",
	"	 ",
	"	 ",
	"		        ",
	"	//mouse rotation ",
	"	float a_xz = 0.9; ",
	"	float a_yz = -.6; ",
	"	float a_xy = 0.9 + time*0.04; ",
	"	 ",
	"	 ",
	"	mat2 rot_xz = mat2(cos(a_xz),sin(a_xz),-sin(a_xz),cos(a_xz)); ",
	"	 ",
	"	mat2 rot_yz = mat2(cos(a_yz),sin(a_yz),-sin(a_yz),cos(a_yz)); ",
	"		 ",
	"	mat2 rot_xy = mat2(cos(a_xy),sin(a_xy),-sin(a_xy),cos(a_xy)); ",
	"	 ",
	" ",
	"	float v2 =1.0; ",
	"	 ",
	"	vec3 dir=vec3(uv*zoom,1.); ",
	"  ",
	"	vec3 from=vec3(0.0, 0.0,0.0); ",
	"  ",
	"                                ",
	"        from.x -= 5.0*(mouse.x-0.5); ",
	"        from.y -= 5.0*(mouse.y-0.5); ",
	"                ",
	"                ",
	"	vec3 forward = vec3(0.,0.,1.); ",
	"                ",
	"	 ",
	"	from.x += transverseSpeed*(1.0)*cos(0.01*time) + 0.001*time; ",
	"		from.y += transverseSpeed*(1.0)*sin(0.01*time) +0.001*time; ",
	"	 ",
	"	from.z += 0.003*time; ",
	"	 ",
	"	 ",
	"	dir.xy*=rot_xy; ",
	"	forward.xy *= rot_xy; ",
	" ",
	"	dir.xz*=rot_xz; ",
	"	forward.xz *= rot_xz; ",
	"		 ",
	"	 ",
	"	dir.yz*= rot_yz; ",
	"	forward.yz *= rot_yz; ",
	"	  ",
	" ",
	"	 ",
	"	from.xy*=-rot_xy; ",
	"	from.xz*=rot_xz; ",
	"	from.yz*= rot_yz; ",
	"	  ",
	"	 ",
	"	//zoom ",
	"	float zooom = (time2-3311.)*speed; ",
	"	from += forward* zooom; ",
	"	float sampleShift = mod( zooom, stepsize ); ",
	"	  ",
	"	float zoffset = -sampleShift; ",
	"	sampleShift /= stepsize; // make from 0 to 1 ",
	" ",
	" ",
	"	 ",
	"	//volumetric rendering ",
	"	float s=0.24; ",
	"	float s3 = s + stepsize/2.0; ",
	"	vec3 v=vec3(0.); ",
	"	float t3 = 0.0; ",
	"	 ",
	"	 ",
	"	vec3 backCol2 = vec3(0.); ",
	"	for (int r=0; r<volsteps; r++) { ",
	"		vec3 p2=from+(s+zoffset)*dir;// + vec3(0.,0.,zoffset); ",
	"		vec3 p3=(from+(s3+zoffset)*dir )* (1.9/zoom);// + vec3(0.,0.,zoffset); ",
	"		 ",
	"		p2 = abs(vec3(tile)-mod(p2,vec3(tile*2.))); // tiling fold ",
	"		p3 = abs(vec3(tile)-mod(p3,vec3(tile*2.))); // tiling fold ",
	"		 ",
	"		#ifdef cloud ",
	"		t3 = field(p3); ",
	"		#endif ",
	"		 ",
	"		float pa,a=pa=0.; ",
	"		for (int i=0; i<iterations; i++) { ",
	"			p2=abs(p2)/dot(p2,p2)-formuparam; // the magic formula ",
	"			//p=abs(p)/max(dot(p,p),0.005)-formuparam; // another interesting way to reduce noise ",
	"			float D = abs(length(p2)-pa); // absolute sum of average change ",
	"			 ",
	"			if (i > 2) ",
	"			{ ",
	"			a += i > 7 ? min( 12., D) : D; ",
	"			} ",
	"				pa=length(p2); ",
	"		} ",
	"		 ",
	"		 ",
	"		//float dm=max(0.,darkmatter-a*a*.001); //dark matter ",
	"		a*=a*a; // add contrast ",
	"		//if (r>3) fade*=1.-dm; // dark matter, don't render near ",
	"		// brightens stuff up a bit ",
	"		float s1 = s+zoffset; ",
	"		// need closed form expression for this, now that we shift samples ",
	"		float fade = pow(distfading,max(0.,float(r)-sampleShift)); ",
	"		 ",
	"		 ",
	"		//t3 += fade; ",
	"		 ",
	"		v+=fade; ",
	"	       		//backCol2 -= fade; ",
	" ",
	"		// fade out samples as they approach the camera ",
	"		if( r == 0 ) ",
	"			fade *= (1. - (sampleShift)); ",
	"		// fade in samples as they approach from the distance ",
	"		if( r == volsteps-1 ) ",
	"			fade *= sampleShift; ",
	"		v+=vec3(s1,s1*s1,s1*s1*s1*s1)*a*brightness*fade; // coloring based on distance ",
	"		 ",
	"		backCol2 += mix(.4, 1., v2) * vec3(0.20 * t3 * t3 * t3, 0.4 * t3 * t3, t3 * 0.7) * fade; ",
	" ",
	"		 ",
	"		s+=stepsize; ",
	"		s3 += stepsize; ",
	"		 ",
	"		 ",
	"		 ",
	"		} ",
	"		        ",
	"	v=mix(vec3(length(v)),v,saturation); //color adjust ",
	"	  ",
	"	 ",
	"	 ",
	" ",
	"	vec4 forCol2 = vec4(v*.01,1.); ",
	"	 ",
	"	#ifdef cloud ",
	"	backCol2 *= cloud; ",
	"	#endif ",
	"	 ",
	"	//backCol2.b *= 1.8; ",
	" ",
	"	//backCol2.r *= 0.05; ",
	"	 ",
	" ",
	"	 ",
	"	//backCol2.b = 0.5*mix(backCol2.b, backCol2.g, 0.2); ",
	"	//backCol2.g = 0.0; ",
	" ",
	"//	backCol2.bg = mix(backCol2.gb, backCol2.bg, 0.5*(cos(time*0.01) + 1.0)); ",
	"	 ",
	"	gl_FragColor = forCol2 + vec4(backCol2, 1.0); ",
	" ",
	" ",
	" ",
	"	 ",
	"  ",
	"} ",
	" ",
].join("\n");

var FRAGS = new Array;
FRAGS.push(frag0);
FRAGS.push(frag1);
FRAGS.push(frag2);
FRAGS.push(frag3);
FRAGS.push(frag4);
FRAGS.push(frag5);
FRAGS.push(frag6);
FRAGS.push(frag7);
FRAGS.push(frag8);



